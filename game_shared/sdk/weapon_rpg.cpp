//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
//=============================================================================//

#include "cbase.h"
#include "weapon_sdkbase.h"
#include "vstdlib/random.h"
#include "engine/IEngineSound.h"
#include "in_buttons.h"
#include "weapon_rpg.h"
#include "shake.h"
#include "collisionutils.h"
#include "takedamageinfo.h"

#ifdef CLIENT_DLL
	#include "c_baseplayer.h"
	#include "cdll_util.h"
	#include "c_te_effect_dispatch.h"
	#include "c_sdk_player.h"
#else
	#include "func_break.h"
	#include "sdk_player.h"
	#include "explode.h"
	#include "entitylist.h"
	#include "player.h"
	#include "util.h"
	#include "triggers.h"
	#include "te_effect_dispatch.h"
#endif

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

#define	RPG_SPEED	1500

const char *g_pLaserDotThink = "LaserThinkContext";

//-----------------------------------------------------------------------------
// Laser Dot
//-----------------------------------------------------------------------------

BEGIN_DATADESC(CLaserDot)
	DEFINE_FIELD( m_vecSurfaceNormal,	FIELD_VECTOR ),
	DEFINE_FIELD( m_hTargetEnt,			FIELD_EHANDLE ),
	DEFINE_FIELD( m_bVisibleLaserDot,	FIELD_BOOLEAN ),
	DEFINE_FIELD( m_bIsOn,				FIELD_BOOLEAN ),

	//DEFINE_FIELD( m_pNext, FIELD_CLASSPTR ),	// don't save - regenerated by constructor
	#ifndef CLIENT_DLL
		DEFINE_THINKFUNC( LaserThink ),
	#endif
END_DATADESC()

LINK_ENTITY_TO_CLASS(env_laserdot, CLaserDot);

//-----------------------------------------------------------------------------
// Networking
//-----------------------------------------------------------------------------
IMPLEMENT_NETWORKCLASS_ALIASED(LaserDot, DT_LaserDot);

BEGIN_NETWORK_TABLE(CLaserDot, DT_LaserDot)
	#ifndef CLIENT_DLL
		SendPropBool(SENDINFO(m_bIsOn)),
		SendPropVector( SENDINFO(m_vecOrigin), -1,  SPROP_COORD),
	#else
		RecvPropBool(RECVINFO(m_bIsOn)),
		RecvPropVector(RECVINFO(m_vecOrigin)),
	#endif
END_NETWORK_TABLE()


//-----------------------------------------------------------------------------
// Prediction
//-----------------------------------------------------------------------------
BEGIN_PREDICTION_DATA(CLaserDot)
END_PREDICTION_DATA()

#ifndef CLIENT_DLL
	// a list of laser dots to search quickly
	CEntityClassList<CLaserDot> g_LaserDotList;
	template<class T>
	T *CEntityClassList<T>::m_pClassList = NULL;
	CLaserDot *GetLaserDotList()
	{
		return g_LaserDotList.m_pClassList;
	}
#endif

//-----------------------------------------------------------------------------
// Missile
//-----------------------------------------------------------------------------

#ifndef CLIENT_DLL

BEGIN_DATADESC( CMissile )

	DEFINE_FIELD( m_hOwner,					FIELD_EHANDLE ),
	DEFINE_FIELD( m_hRocketTrail,			FIELD_EHANDLE ),
	DEFINE_FIELD( m_flAugerTime,			FIELD_TIME ),
	DEFINE_FIELD( m_flMarkDeadTime,			FIELD_TIME ),
	DEFINE_FIELD( m_flGracePeriodEndsAt,	FIELD_TIME ),
	DEFINE_FIELD( m_flDamage,				FIELD_FLOAT ),
	
	// Function Pointers
	DEFINE_ENTITYFUNC( MissileTouch ),
	DEFINE_THINKFUNC( AccelerateThink ),
	DEFINE_THINKFUNC( AugerThink ),
	DEFINE_THINKFUNC( IgniteThink ),
	DEFINE_THINKFUNC( SeekThink ),

END_DATADESC()

#endif

LINK_ENTITY_TO_CLASS( rpg_missile, CMissile );

class CWeaponRPG;


//-----------------------------------------------------------------------------
// Constructor
//-----------------------------------------------------------------------------
CMissile::CMissile()
{
	m_hRocketTrail = NULL;

	// max health
	m_iMaxHealth = MISSLE_MAX_HEALTH;
}

CMissile::~CMissile()
{
	if (m_hRocketTrail) {
		m_hRocketTrail->SetLifetime( 0.1f );
		m_hRocketTrail = NULL;
	}
}


//-----------------------------------------------------------------------------
// Purpose: 
//
//
//-----------------------------------------------------------------------------
void CMissile::Precache( void )
{
	PrecacheModel( "models/mod_weapons/rocket.mdl" );
}


//-----------------------------------------------------------------------------
// Purpose: 
//
//
//-----------------------------------------------------------------------------
void CMissile::Spawn( void )
{
	Precache();

	SetSolid( SOLID_BBOX );
	//SetModel("models/weapons/w_missile_launch.mdl");

#ifndef CLIENT_DLL
	UTIL_SetSize( this, -Vector(4,4,4), Vector(4,4,4) );
#endif
	
	SetTouch( &CMissile::MissileTouch );

	SetMoveType( MOVETYPE_FLYGRAVITY, MOVECOLLIDE_FLY_CUSTOM );
	SetThink( &CMissile::IgniteThink );
	
	SetNextThink( gpGlobals->curtime + 0.1f );
	SetDamage( 250.0f );

	m_takedamage = DAMAGE_YES;
	m_iHealth = m_iMaxHealth = 100;
	m_bloodColor = DONT_BLEED;
	m_flGracePeriodEndsAt = 0;

	AddFlag( FL_OBJECT );
}


//---------------------------------------------------------
//---------------------------------------------------------
void CMissile::Event_Killed( const CTakeDamageInfo &info )
{
	m_takedamage = DAMAGE_NO;

	ShotDown();
}

unsigned int CMissile::PhysicsSolidMaskForEntity( void ) const
{ 
	return BaseClass::PhysicsSolidMaskForEntity() | CONTENTS_HITBOX;
}

#ifndef CLIENT_DLL
	//---------------------------------------------------------
	//---------------------------------------------------------
	int CMissile::OnTakeDamage_Alive( const CTakeDamageInfo &info )
	{
		// @TRJ - let's let anything do damage... it could be interesting
		/*if ( ( info.GetDamageType() & (DMG_MISSILEDEFENSE | DMG_AIRBOAT) ) == false )
			return 0;*/

		bool bIsDamaged;
		if( m_iHealth <= AugerHealth() )
		{
			// This missile is already damaged (i.e., already running AugerThink)
			bIsDamaged = true;
		}
		else
		{
			// This missile isn't damaged enough to wobble in flight yet
			bIsDamaged = false;
		}
		
		int nRetVal = BaseClass::OnTakeDamage_Alive( info );

		if( !bIsDamaged )
		{
			if ( m_iHealth <= AugerHealth() )
			{
				ShotDown();
			}
		}

		return nRetVal;
	}
#endif

//-----------------------------------------------------------------------------
// Purpose: Stops any kind of tracking and shoots dumb
//-----------------------------------------------------------------------------
void CMissile::DumbFire( void )
{
	SetThink( NULL );
	SetMoveType( MOVETYPE_FLY, MOVECOLLIDE_FLY_CUSTOM );

	SetModel("models/mod_weapons/rocket.mdl");

#ifndef CLIENT_DLL
	UTIL_SetSize( this, vec3_origin, vec3_origin );
#endif

	EmitSound( "Missile.Ignite" );

#ifndef CLIENT_DLL
	// Smoke trail.
	CreateSmokeTrail();
#endif
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CMissile::SetGracePeriod( float flGracePeriod )
{
	m_flGracePeriodEndsAt = gpGlobals->curtime + flGracePeriod;

	// @TRJ - solid immediately
	// Go non-solid until the grace period ends
	//AddSolidFlags( FSOLID_NOT_SOLID );
}

//---------------------------------------------------------
//---------------------------------------------------------
void CMissile::AccelerateThink( void )
{
	Vector vecForward;

	// !!!UNDONE - make this work exactly the same as HL1 RPG, lest we have looping sound bugs again!
	EmitSound( "Missile.Accelerate" );

	// SetEffects( EF_LIGHT );

	AngleVectors( GetLocalAngles(), &vecForward );
	SetAbsVelocity( vecForward * RPG_SPEED );

	//SetThink( SeekThink );
	SetThink( NULL );
	SetNextThink( TICK_NEVER_THINK );
}

#define AUGER_YDEVIANCE 20.0f
#define AUGER_XDEVIANCEUP 8.0f
#define AUGER_XDEVIANCEDOWN 1.0f

//---------------------------------------------------------
//---------------------------------------------------------
void CMissile::AugerThink( void )
{
	// If we've augered long enough, then just explode
	if ( m_flAugerTime < gpGlobals->curtime )
	{
		Explode(NULL);
		return;
	}

	if ( m_flMarkDeadTime < gpGlobals->curtime )
	{
		m_lifeState = LIFE_DYING;
	}

	QAngle angles = GetLocalAngles();

	angles.y += random->RandomFloat( -AUGER_YDEVIANCE, AUGER_YDEVIANCE );
	angles.x += random->RandomFloat( -AUGER_XDEVIANCEDOWN, AUGER_XDEVIANCEUP );

	SetLocalAngles( angles );

	Vector vecForward;

	AngleVectors( GetLocalAngles(), &vecForward );
	
	SetAbsVelocity( vecForward * 1000.0f );

	SetNextThink( gpGlobals->curtime + 0.05f );
}

//-----------------------------------------------------------------------------
// Purpose: Causes the missile to spiral to the ground and explode, due to damage
//-----------------------------------------------------------------------------
void CMissile::ShotDown( void )
{
	CEffectData	data;
	data.m_vOrigin = GetAbsOrigin();

	DispatchEffect( "RPGShotDown", data );

	if ( m_hRocketTrail != NULL )
	{
		m_hRocketTrail->m_bDamaged = true;
	}

	SetThink( &CMissile::AugerThink );
	SetNextThink( gpGlobals->curtime );
	m_flAugerTime = gpGlobals->curtime + 1.5f;
	m_flMarkDeadTime = gpGlobals->curtime + 0.75;

	// Let the RPG start reloading immediately
	if ( m_hOwner != NULL )
	{
		m_hOwner->NotifyRocketDied();
		m_hOwner = NULL;
	}
}


#ifndef CLIENT_DLL
	//-----------------------------------------------------------------------------
	// The actual explosion 
	//-----------------------------------------------------------------------------
	void CMissile::DoExplosion( void )
	{
		// Explode
		ExplosionCreate( GetAbsOrigin(), GetAbsAngles(), GetOwnerEntity(), GetDamage(), 250, 
			SF_ENVEXPLOSION_NOSPARKS | SF_ENVEXPLOSION_NODLIGHTS | SF_ENVEXPLOSION_NOSMOKE, 0.0f, this);
	}
#endif

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CMissile::Explode(CBaseEntity *pOther)
{
	// Don't explode against the skybox. Just pretend that 
	// the missile flies off into the distance.
	Vector forward;
	bool bHitGlass;

	GetVectors( &forward, NULL, NULL );

	trace_t tr;
	UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + forward * 16, MASK_SHOT, this, COLLISION_GROUP_NONE, &tr );

	// see if we hit glass
	bHitGlass = pOther && pOther->GetCollisionGroup() == COLLISION_GROUP_BREAKABLE_GLASS;
#ifndef CLIENT_DLL
	CBreakable *pBreakable;

	// see if it was breakable glass
	pBreakable = dynamic_cast<CBreakable *>(pOther);
	bHitGlass = bHitGlass || (pBreakable && pBreakable->GetMaterialType() == matGlass);
#endif

	// @TRJ - keep going if we hit glass
	if(bHitGlass)
	{
		// see if we can hurt it
		if(pOther && pOther->m_takedamage != DAMAGE_NO)
		{
			ClearMultiDamage();

			Vector	vecNormalizedVel = GetAbsVelocity();
			trace_t	tr;

			// figure out the direction
			VectorNormalize( vecNormalizedVel );

			// hurt the glass so it breaks
			CTakeDamageInfo	dmgInfo(this, GetOwnerEntity(), pOther->GetHealth() + 1, DMG_BLAST | DMG_NEVERGIB);
			CalculateMeleeDamageForce(&dmgInfo, vecNormalizedVel, tr.endpos, 0.7f);
			dmgInfo.SetDamagePosition(tr.endpos);
			pOther->DispatchTraceAttack(dmgInfo, vecNormalizedVel, &tr);

			ApplyMultiDamage();
		}

		return;
	}

	m_takedamage = DAMAGE_NO;
	SetSolid( SOLID_NONE );
	SetNextThink( TICK_NEVER_THINK );

#ifndef CLIENT_DLL
	if( tr.fraction == 1.0 || !(tr.surface.flags & SURF_SKY) )
	{
		DoExplosion();
	}
#endif

	if( m_hRocketTrail )
	{
		m_hRocketTrail->SetLifetime(0.1f);
		m_hRocketTrail = NULL;
	}

	if ( m_hOwner != NULL )
	{
		m_hOwner->NotifyRocketDied();
		m_hOwner = NULL;
	}

	StopSound( "Missile.Ignite" );
	EmitSound( "Missile.Explode" );

#ifndef CLIENT_DLL
	UTIL_Remove( this );
#endif
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pOther - 
//-----------------------------------------------------------------------------
void CMissile::MissileTouch( CBaseEntity *pOther )
{
	Assert( pOther );
	
	// Don't touch triggers (but DO hit weapons)
	if ( pOther->IsSolidFlagSet(FSOLID_TRIGGER|FSOLID_VOLUME_CONTENTS) && pOther->GetCollisionGroup() != COLLISION_GROUP_WEAPON )
		return;

	Explode(pOther);
}

#ifndef CLIENT_DLL
	//-----------------------------------------------------------------------------
	// Purpose: 
	//-----------------------------------------------------------------------------
	void CMissile::CreateSmokeTrail( void )
	{
		if ( m_hRocketTrail )
			return;

		// our missle is already destroyed, don't create the smoke trail
		if (m_takedamage == DAMAGE_NO)
			return;

		// Smoke trail.
		if ( (m_hRocketTrail = RocketTrail::CreateRocketTrail()) != NULL )
		{
			m_hRocketTrail->m_Opacity = 0.2f;
			m_hRocketTrail->m_SpawnRate = 100;
			m_hRocketTrail->m_ParticleLifetime = 0.5f;
			m_hRocketTrail->m_StartColor.Init( 0.65f, 0.65f , 0.65f );
			m_hRocketTrail->m_EndColor.Init( 0.0, 0.0, 0.0 );
			m_hRocketTrail->m_StartSize = 8;
			m_hRocketTrail->m_EndSize = 32;
			m_hRocketTrail->m_SpawnRadius = 4;
			m_hRocketTrail->m_MinSpeed = 2;
			m_hRocketTrail->m_MaxSpeed = 16;
			
			// was 999. unlikely that any missle will go for more than
			// 30 seconds, and it helps with the sprite that won't die
			m_hRocketTrail->SetLifetime( 30 );	
			m_hRocketTrail->FollowEntity( this, "0" );
		}
	}

	/**
	* Called when the missile is destroyed.  Attempting to kill the permiflame
	*
	* @return void
	**/
	void CMissile::UpdateOnRemove(void)
	{
		RocketTrail *pTrail;

		// kill the rocket trail
		pTrail = m_hRocketTrail.Get();
		if(pTrail)
			UTIL_Remove(pTrail);

		// jump down
		BaseClass::UpdateOnRemove();
	}
#endif


//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CMissile::IgniteThink( void )
{
	SetMoveType( MOVETYPE_FLY, MOVECOLLIDE_FLY_CUSTOM );
	SetModel("models/mod_weapons/rocket.mdl");

#ifndef CLIENT_DLL
	UTIL_SetSize( this, vec3_origin, vec3_origin );
#endif
 	//RemoveSolidFlags( FSOLID_NOT_SOLID );

	//TODO: Play opening sound

	Vector vecForward;

	EmitSound( "Missile.Ignite" );

	AngleVectors( GetLocalAngles(), &vecForward );
	SetAbsVelocity( vecForward * RPG_SPEED );

	//SetThink( SeekThink );
	SetThink( NULL );
	SetNextThink( TICK_NEVER_THINK );

#ifndef CLIENT_DLL
	if ( m_hOwner && m_hOwner->GetOwner() )
	{
		CBasePlayer *pPlayer = ToBasePlayer( m_hOwner->GetOwner() );

		color32 white = { 255,225,205,64 };
		UTIL_ScreenFade( pPlayer, white, 0.1f, 0.0f, FFADE_IN );
	}

	CreateSmokeTrail();
#endif
}


//-----------------------------------------------------------------------------
// Gets the shooting position 
//-----------------------------------------------------------------------------
void CMissile::GetShootPosition( CLaserDot *pLaserDot, Vector *pShootPosition )
{
	if ( pLaserDot->GetOwnerEntity() != NULL )
	{
		//FIXME: Do we care this isn't exactly the muzzle position?
		*pShootPosition = pLaserDot->GetOwnerEntity()->WorldSpaceCenter();
	}
	else
	{
		*pShootPosition = pLaserDot->GetChasePosition();
	}
}

	
//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
#define	RPG_HOMING_SPEED	0.125f

#ifndef CLIENT_DLL
	void CMissile::ComputeActualDotPosition( CLaserDot *pLaserDot, Vector *pActualDotPosition, float *pHomingSpeed )
	{
		*pHomingSpeed = RPG_HOMING_SPEED;
		if ( pLaserDot->GetTargetEntity() )
		{
			*pActualDotPosition = pLaserDot->GetChasePosition();
			return;
		}

		Vector vLaserStart;
		GetShootPosition( pLaserDot, &vLaserStart );

		//Get the laser's vector
		Vector vLaserDir;
		VectorSubtract( pLaserDot->GetChasePosition(), vLaserStart, vLaserDir );
		
		//Find the length of the current laser
		float flLaserLength = VectorNormalize( vLaserDir );
		
		//Find the length from the missile to the laser's owner
		float flMissileLength = GetAbsOrigin().DistTo( vLaserStart );

		//Find the length from the missile to the laser's position
		Vector vecTargetToMissile;
		VectorSubtract( GetAbsOrigin(), pLaserDot->GetChasePosition(), vecTargetToMissile ); 
		float flTargetLength = VectorNormalize( vecTargetToMissile );

		// See if we should chase the line segment nearest us
		if ( ( flMissileLength < flLaserLength ) || ( flTargetLength <= 512.0f ) )
		{
			*pActualDotPosition = UTIL_PointOnLineNearestPoint( vLaserStart, pLaserDot->GetChasePosition(), GetAbsOrigin() );
			*pActualDotPosition += ( vLaserDir * 256.0f );
		}
		else
		{
			// Otherwise chase the dot
			*pActualDotPosition = pLaserDot->GetChasePosition();
		}

	//	NDebugOverlay::Line( pLaserDot->GetChasePosition(), vLaserStart, 0, 255, 0, true, 0.05f );
	//	NDebugOverlay::Line( GetAbsOrigin(), *pActualDotPosition, 255, 0, 0, true, 0.05f );
	//	NDebugOverlay::Cross3D( *pActualDotPosition, -Vector(4,4,4), Vector(4,4,4), 255, 0, 0, true, 0.05f );
	}
#endif

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CMissile::SeekThink( void )
{
#ifndef CLIENT_DLL
	CBaseEntity	*pBestDot	= NULL;
	float		flBestDist	= MAX_TRACE_LENGTH;
	float		dotDist;

	// If we have a grace period, go solid when it ends
	if ( m_flGracePeriodEndsAt )
	{
		if ( m_flGracePeriodEndsAt < gpGlobals->curtime )
		{
			RemoveSolidFlags( FSOLID_NOT_SOLID );
			m_flGracePeriodEndsAt = 0;
		}
	}

	//Search for all dots relevant to us
	for( CLaserDot *pEnt = GetLaserDotList(); pEnt != NULL; pEnt = pEnt->m_pNext )
	{
		if ( !pEnt->IsOn() )
			continue;

		if ( pEnt->GetOwnerEntity() != GetOwnerEntity() )
			continue;

		dotDist = (GetAbsOrigin() - pEnt->GetAbsOrigin()).Length();

		//Find closest
		if ( dotDist < flBestDist )
		{
			pBestDot	= pEnt;
			flBestDist	= dotDist;
		}
	}

	//If we have a dot target
	if ( pBestDot == NULL )
	{
		//Think as soon as possible
		SetNextThink( gpGlobals->curtime );
		return;
	}

	CLaserDot *pLaserDot = (CLaserDot *)pBestDot;
	Vector	targetPos;

	float flHomingSpeed; 
	Vector vecLaserDotPosition;
	ComputeActualDotPosition( pLaserDot, &targetPos, &flHomingSpeed );

	if ( IsSimulatingOnAlternateTicks() )
		flHomingSpeed *= 2;

	Vector	vTargetDir;
	VectorSubtract( targetPos, GetAbsOrigin(), vTargetDir );
	float flDist = VectorNormalize( vTargetDir );

	Vector	vDir	= GetAbsVelocity();
	float	flSpeed	= VectorNormalize( vDir );
	Vector	vNewVelocity = vDir;
	if ( gpGlobals->frametime > 0.0f )
	{
		if ( flSpeed != 0 )
		{
			vNewVelocity = ( flHomingSpeed * vTargetDir ) + ( ( 1 - flHomingSpeed ) * vDir );

			// This computation may happen to cancel itself out exactly. If so, slam to targetdir.
			if ( VectorNormalize( vNewVelocity ) < 1e-3 )
			{
				vNewVelocity = (flDist != 0) ? vTargetDir : vDir;
			}
		}
		else
		{
			vNewVelocity = vTargetDir;
		}
	}

	QAngle	finalAngles;
	VectorAngles( vNewVelocity, finalAngles );
	SetAbsAngles( finalAngles );

	vNewVelocity *= flSpeed;
	SetAbsVelocity( vNewVelocity );

	if( GetAbsVelocity() == vec3_origin )
	{
		// Strange circumstances have brought this missile to halt. Just blow it up.
		Explode(NULL);
		return;
	}

	// Think as soon as possible
	SetNextThink( gpGlobals->curtime );
#endif
	/**
	* Client side doesn't do anything... this may or may not be the case
	**/
}

//-----------------------------------------------------------------------------
// Purpose: 
//
// Input  : &vecOrigin - 
//			&vecAngles - 
//			NULL - 
//
// Output : CMissile
//-----------------------------------------------------------------------------
CMissile *CMissile::Create( const Vector &vecOrigin, const QAngle &vecAngles, edict_t *pentOwner)
{
#ifndef CLIENT_DLL
	CMissile *pMissile = (CMissile *) CBaseEntity::Create( "rpg_missile", vecOrigin, vecAngles, CBaseEntity::Instance( pentOwner ) );
	pMissile->SetOwnerEntity( Instance( pentOwner ) );
#else
	CMissile *pMissile = (CMissile *)CreateEntityByName("rpg_missile" );
	//pMissile->SetLocalOrigin(vecOrigin);
	pMissile->SetLocalAngles(vecAngles);
	pMissile->SetOwnerEntity(CBasePlayer::GetLocalPlayer()); // big assumption, the player has created this missle...
#endif

	pMissile->Spawn();
	pMissile->AddEffects( EF_NOSHADOW );
	
	Vector vecForward;
	AngleVectors( vecAngles, &vecForward );

	pMissile->SetAbsVelocity( vecForward * 300 + Vector( 0,0, 128 ) );

	return pMissile;
}

#define	RPG_BEAM_SPRITE		"effects/laser1_noz.vmt"
#define	RPG_LASER_SPRITE	"sprites/redglow1.vmt"

//=============================================================================
// RPG
//=============================================================================

IMPLEMENT_NETWORKCLASS_ALIASED(WeaponRPG, DT_WeaponRPG)

BEGIN_NETWORK_TABLE(CWeaponRPG, DT_WeaponRPG)
END_NETWORK_TABLE()

BEGIN_PREDICTION_DATA(CWeaponRPG)
END_PREDICTION_DATA()
 
LINK_ENTITY_TO_CLASS(weapon_rpg, CWeaponRPG);
PRECACHE_WEAPON_REGISTER(weapon_rpg);

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
CWeaponRPG::CWeaponRPG()
{
	m_bReloadsSingly = true;
	m_bPointerOn = false;

	m_fMinRange1 = m_fMinRange2 = 40*12;
	m_fMaxRange1 = m_fMaxRange2 = 500*12;
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
CWeaponRPG::~CWeaponRPG()
{
	if ( m_hLaserDot != NULL )
	{
		#ifndef CLIENT_DLL
			UTIL_Remove( m_hLaserDot );
		#endif

		m_hLaserDot = NULL;
	}
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponRPG::Precache( void )
{
	BaseClass::Precache();

	PrecacheScriptSound( "Missile.Ignite" );
	PrecacheScriptSound( "Missile.Accelerate" );
	PrecacheScriptSound( "Missile.Explode" );

	// Laser dot...
	PrecacheModel( "sprites/redglow1.vmt" );
	PrecacheModel( RPG_LASER_SPRITE );
	PrecacheModel( RPG_BEAM_SPRITE );

	UTIL_PrecacheOther( "rpg_missile" );
}

#ifndef CLIENT_DLL

/**
* Called when the RPG is about to be destroyed
*
* @return void
**/
void CWeaponRPG::UpdateOnRemove(void)
{
	CMissile *pMissile;

	// destroy the missile
	pMissile = m_hMissile.Get();
	if(pMissile)
		UTIL_Remove(pMissile);

	// jump down
	BaseClass::UpdateOnRemove();
}

#endif

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
bool CWeaponRPG::HasAnyAmmo( void )
{
	if ( m_hMissile != NULL )
		return true;

	return BaseClass::HasAnyAmmo();
}

/**
* Performs the secondary attack.
* Toggle the frickin' laser beam!
*
* @return void
**/
void CWeaponRPG::SecondaryAttack(void)
{
	// make sure we don't have the button held down
	CSDKPlayer *pPlayer = GetPlayerOwner();
	if (!(pPlayer->m_afButtonPressed & IN_ATTACK2)) {
		return;
	}

	// toggle the laser beam
	TogglePointer();
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponRPG::PrimaryAttack( void )
{
	// Can't have an active missile out
	if ( m_hMissile != NULL )
		return;

	// Can't be reloading
	if ( GetActivity() == ACT_VM_RELOAD )
		return;

	Vector vecOrigin;
	Vector vecForward;

	CSDKPlayer *pOwner = ToSDKPlayer( GetOwner() );
	
	if ( pOwner == NULL )
		return;

	Vector	vForward, vRight, vUp, vMuzzlePoint;
	pOwner->EyeVectors( &vForward, &vRight, &vUp );

	vMuzzlePoint = GetMuzzlePoint();

	QAngle vecAngles;
	VectorAngles( vForward, vecAngles );
#ifdef CLIENT_DLL
	m_hMissile = CMissile::Create(vMuzzlePoint, vecAngles);
#else
	m_hMissile = CMissile::Create(vMuzzlePoint, vecAngles, GetOwner()->edict());
	m_hMissile->m_hOwner = this;
#endif

	// did we get a missle?
	if(!m_hMissile)
		return;
	
	m_flNextPrimaryAttack = gpGlobals->curtime + 0.3f;

	// If the shot is to clear the player, give the missile a grace period
	trace_t	tr;
	Vector vecEye = pOwner->EyePosition();
	UTIL_TraceLine( vecEye, vecEye + vForward * 128, MASK_SHOT, this, COLLISION_GROUP_NONE, &tr );
	if ( tr.fraction == 1.0 )
	{
		m_hMissile->SetGracePeriod( 0.1 );
	}

	DecrementAmmo( GetOwner() );

#ifndef CLIENT_DLL
	// Register a muzzleflash for the AI
	pOwner->SetMuzzleFlashTime( gpGlobals->curtime + 0.3 );
#endif

	pOwner->DoAnimationEvent(PLAYERANIMEVENT_FIRE_GUN_PRIMARY);
	pOwner->SetAnimation( PLAYER_ATTACK1 );
	SendWeaponAnim( ACT_VM_PRIMARYATTACK );

	WeaponSound( SINGLE );
	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration());

#ifndef CLIENT_DLL
	// @TRJ - send out the weapon_fire event
	IGameEvent *pEvent = gameeventmanager->CreateEvent("weapon_fire");
	if(pEvent)
	{
		// pull the skill
		CSkillClass *pSkill = pOwner->GetSkillClass();

		// set all the data
		pEvent->SetString("weapon", "rpg_missile");
		pEvent->SetString("skill", pSkill ? pSkill->GetInternalClassName() : "none");
		pEvent->SetInt("userid", pOwner->GetUserID());

		// send it out
		gameeventmanager->FireEvent(pEvent, true);
	}
#endif
}

Vector CWeaponRPG::GetMuzzlePoint()
{
	//int iAttachment;
	//QAngle qaJunk;
	Vector vForward, vRight, vUp, vMuzzlePoint;

	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
	pOwner->EyeVectors( &vForward, &vRight, &vUp );
    
	vMuzzlePoint = pOwner->Weapon_ShootPosition();
	
	// @JD - This is a complete hack...
	// can't do that because otherwise the rocket will spawn behind us and kill us unexpectedly
	//VectorMA(vMuzzlePoint, -15.0, vForward, vMuzzlePoint);
	VectorMA(vMuzzlePoint, 7.0, vRight, vMuzzlePoint);
	VectorMA(vMuzzlePoint, -10.0, vUp, vMuzzlePoint);
	
	return vMuzzlePoint;

	/*

	// figure out where to fire from
	iAttachment = LookupAttachment("muzzle");
	if(iAttachment == 0)
		iAttachment = 1;

	// try to get the attachment
	if(!GetAttachment(iAttachment, vMuzzlePoint, qaJunk)) {
		DevMsg("Couldn't find muzzle attachment point!\n");
		return pOwner->Weapon_ShootPosition() + vForward * 12.0f + vRight * 6.0f + vUp * -3.0f;
	}

	// @JD HACKHACK
#ifdef GAME_DLL
	vMuzzlePoint.z += 34;
#endif

	return vMuzzlePoint;  // sv: -2.1436949 cl: 32.718956   (12.14, -332.66) (12.09, -332.63)
	*/
}


void CWeaponRPG::WeaponIdle()
{
	if (m_flTimeWeaponIdle < gpGlobals->curtime)
	{
		if (GetAmmo1() > 0)
			SendWeaponAnim(ACT_VM_IDLE);
		else
			SendWeaponAnim(ACT_VM_IDLE_EMPTY);
	}

	BaseClass::WeaponIdle();
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pOwner - 
//-----------------------------------------------------------------------------
void CWeaponRPG::DecrementAmmo( CBaseCombatCharacter *pOwner )
{
	// decrement by 1
	m_iAmmo1 -= 1;

	// Take away our primary ammo type
	//pOwner->RemoveAmmo( 1, m_iPrimaryAmmoType );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponRPG::ItemPostFrame( void )
{
	BaseClass::ItemPostFrame();

	CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
	
	if ( pPlayer == NULL )
		return;

	// make sure the dot is in the correct state
	if(m_hLaserDot != NULL)
	{
		// what state?
		if(IsPointerOn() && !m_hLaserDot->IsOn())
			m_hLaserDot->TurnOn();
		else if(!IsPointerOn() && m_hLaserDot->IsOn())
			m_hLaserDot->TurnOff();
	}

#ifndef CLIENT_DLL
	//Move the laser
	UpdateLaserPosition();
#endif
	UpdateLaserEffects();
}

#ifndef CLIENT_DLL
	/**
	* Called every frame when we run out of ammo
	*
	* @return void
	**/
	void CWeaponRPG::OutOfAmmo(void)
	{
		// grab the player
		CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
		
		// make sure we got them
		if (pPlayer == NULL)
			return;

		// drop the weapon and then destroy it
		pPlayer->Weapon_Drop(this);
		UTIL_Remove(this);
		
		// go down
		BaseClass::OutOfAmmo();
	}
#endif

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
bool CWeaponRPG::Holster( CBaseCombatWeapon *pSwitchingTo )
{
	//Can't have an active missile out
	// JD - sure you can.
	/*
    if ( m_hMissile != NULL )
		return false;
	*/

	StopPointer();

#ifndef CLIENT_DLL
	// If they attempt to switch weapons before the throw animation is done, 
	// allow it, but kill the weapon if we have to.
	CSDKPlayer *pPlayer = GetPlayerOwner();
	
	if( pPlayer->IsAlive() && GetAmmo1() <= 0 )
	{
		CBaseCombatCharacter *pOwner = (CBaseCombatCharacter *)pPlayer;
		pOwner->Weapon_Drop( this );
		UTIL_Remove(this);
	}
#endif

	return BaseClass::Holster( pSwitchingTo );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponRPG::Drop( const Vector &vecVelocity )
{
	StopPointer();
	BaseClass::Drop( vecVelocity );
}

/**
* Deploys the weapon
*
* @return void
**/
bool CWeaponRPG::Deploy(void)
{
	// see if we can do it
	if(BaseClass::Deploy())
	{
		// is the laser off?
		if(!m_bPointerOn)
			TogglePointer();

		return true;
	}

	return false;
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponRPG::UpdateLaserPosition( Vector vecMuzzlePos, Vector vecEndPos )
{
	if ( vecMuzzlePos == vec3_origin || vecEndPos == vec3_origin )
	{
		CBasePlayer *pPlayer = ToBasePlayer( GetOwner() );
		if ( !pPlayer )
			return;

		vecMuzzlePos = pPlayer->Weapon_ShootPosition();
		Vector	forward;
		pPlayer->EyeVectors( &forward );
		vecEndPos = vecMuzzlePos + ( forward * MAX_TRACE_LENGTH );
	}

	//Move the laser dot, if active
	trace_t	tr;
	
	// Trace out for the endpoint
	UTIL_TraceLine( vecMuzzlePos, vecEndPos, (MASK_SHOT & ~CONTENTS_WINDOW), this, COLLISION_GROUP_NONE, &tr );

	// Move the laser sprite
	if ( m_hLaserDot != NULL )
	{
		Vector	laserPos = tr.endpos;
		m_hLaserDot->SetLaserPosition( laserPos, tr.plane.normal );
		
		if ( tr.DidHitNonWorldEntity() )
		{
			CBaseEntity *pHit = tr.m_pEnt;

			if ( ( pHit != NULL ) && ( pHit->m_takedamage ) )
			{
				m_hLaserDot->SetTargetEntity( pHit );
			}
			else
			{
				m_hLaserDot->SetTargetEntity( NULL );
			}
		}
		else
		{
			m_hLaserDot->SetTargetEntity( NULL );
		}
	}
}

//-----------------------------------------------------------------------------
// Purpose:
//-----------------------------------------------------------------------------
void CWeaponRPG::CreateLaserPointer( void )
{
	if ( m_hLaserDot != NULL )
		return;

#ifndef CLIENT_DLL
	m_hLaserDot = CLaserDot::Create( GetAbsOrigin(), GetOwnerEntity() );
	m_hLaserDot->TurnOff();

	UpdateLaserPosition();
#endif
}

//-----------------------------------------------------------------------------
// Purpose: Turn on the guiding laser
//-----------------------------------------------------------------------------
void CWeaponRPG::StartPointer( void )
{
	m_bPointerOn = true;

	//WeaponSound(SPECIAL1);

	CreateLaserPointer();
	StartLaserEffects();
}

//-----------------------------------------------------------------------------
// Purpose: Turn off the guiding laser
//-----------------------------------------------------------------------------
void CWeaponRPG::StopPointer( void )
{
	m_bPointerOn = false;

	//WeaponSound( SPECIAL2 );

	StopLaserEffects();

	// Kill the dot completely
	if ( m_hLaserDot != NULL )
	{
		m_hLaserDot->TurnOff();

		#ifndef CLIENT_DLL
			UTIL_Remove( m_hLaserDot );
			m_hLaserDot = NULL;
		#endif
	}
}

//-----------------------------------------------------------------------------
// Purpose: Toggle the guiding laser
//-----------------------------------------------------------------------------
void CWeaponRPG::TogglePointer( void )
{
	if(IsPointerOn())
		StopPointer();
	else
		StartPointer();
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponRPG::NotifyRocketDied( void )
{
	m_hMissile = NULL;

	Reload();
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
bool CWeaponRPG::Reload( void )
{
	CBaseCombatCharacter *pOwner = GetOwner();
	
	if ( pOwner == NULL )
		return false;

	if ( pOwner->GetAmmoCount(m_iPrimaryAmmoType) <= 0 )
		return false;

	WeaponSound( RELOAD );
	
	SendWeaponAnim( ACT_VM_RELOAD );

	return true;
}

//-----------------------------------------------------------------------------
// Purpose: Start the effects on the viewmodel of the RPG
//-----------------------------------------------------------------------------
void CWeaponRPG::StartLaserEffects( void )
{
	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );
	if ( pOwner == NULL )
		return;

	CBaseViewModel *pBeamEnt = static_cast<CBaseViewModel *>(pOwner->GetViewModel());

	if ( m_hLaserBeam == NULL )
	{
		m_hLaserBeam = CBeam::BeamCreate( RPG_BEAM_SPRITE, 1.0f );
		
		if ( m_hLaserBeam == NULL )
		{
			// We were unable to create the beam
			//Assert(0);
			return;
		}

		m_hLaserBeam->EntsInit( pBeamEnt, pBeamEnt );

		int	startAttachment = LookupAttachment( "laser" );
		int endAttachment	= LookupAttachment( "laser_end" );

		m_hLaserBeam->FollowEntity( pBeamEnt );
		m_hLaserBeam->SetStartAttachment( startAttachment );
		m_hLaserBeam->SetEndAttachment( endAttachment );
		m_hLaserBeam->SetNoise( 0 );
		m_hLaserBeam->SetColor( 255, 0, 0 );
		m_hLaserBeam->SetScrollRate( 0 );
		m_hLaserBeam->SetWidth( 0.5f );
		m_hLaserBeam->SetEndWidth( 0.5f );
		m_hLaserBeam->SetBrightness( 128 );
		m_hLaserBeam->SetBeamFlags( SF_BEAM_SHADEIN );
	}
	else
	{
		m_hLaserBeam->SetBrightness( 128 );
	}

#ifndef CLIENT_DLL
	if ( m_hLaserMuzzleSprite == NULL )
	{
		m_hLaserMuzzleSprite = CSprite::SpriteCreate( RPG_LASER_SPRITE, GetAbsOrigin(), false );

		if ( m_hLaserMuzzleSprite == NULL )
		{
			// We were unable to create the sprite
			Assert(0);
			return;
		}

		m_hLaserMuzzleSprite->SetAttachment( pOwner->GetViewModel(), LookupAttachment( "laser" ) );
		m_hLaserMuzzleSprite->SetTransparency( kRenderTransAdd, 255, 255, 255, 255, kRenderFxNoDissipation );
		m_hLaserMuzzleSprite->SetBrightness( 255, 0.5f );
		m_hLaserMuzzleSprite->SetScale( 0.25f, 0.5f );
		m_hLaserMuzzleSprite->TurnOn();
	}
	else
	{
		m_hLaserMuzzleSprite->TurnOn();
		m_hLaserMuzzleSprite->SetScale( 0.25f, 0.25f );
		m_hLaserMuzzleSprite->SetBrightness( 255 );
	}
#endif
}

//-----------------------------------------------------------------------------
// Purpose: Stop the effects on the viewmodel of the RPG
//-----------------------------------------------------------------------------
void CWeaponRPG::StopLaserEffects( void )
{
	if ( m_hLaserBeam != NULL )
	{
		m_hLaserBeam->SetBrightness( 0 );
#ifdef GAME_DLL
		UTIL_Remove(m_hLaserBeam);
#endif
		m_hLaserBeam = NULL;
	}
	
	if ( m_hLaserMuzzleSprite != NULL )
	{
		m_hLaserMuzzleSprite->SetScale( 0.01f );
		m_hLaserMuzzleSprite->SetBrightness( 0, 0.5f );
#ifdef GAME_DLL
		UTIL_Remove(m_hLaserMuzzleSprite);
#endif
		m_hLaserMuzzleSprite = NULL;
	}
}

//-----------------------------------------------------------------------------
// Purpose: Pulse all the effects to make them more... well, laser-like
//-----------------------------------------------------------------------------
void CWeaponRPG::UpdateLaserEffects( void )
{
	if(!IsPointerOn())
		return;

	if ( m_hLaserBeam != NULL )
	{
		m_hLaserBeam->SetBrightness( 128 + random->RandomInt( -8, 8 ) );
	}

	if ( m_hLaserMuzzleSprite != NULL )
	{
		m_hLaserMuzzleSprite->SetScale( 0.1f + random->RandomFloat( -0.025f, 0.025f ) );
	}
}

//=============================================================================
// Laser Dot
//=============================================================================

void SetLaserDotTarget( CBaseEntity *pLaserDot, CBaseEntity *pTarget )
{
	CLaserDot *pDot = assert_cast< CLaserDot* >(pLaserDot );
	pDot->SetTargetEntity( pTarget );
}

void EnableLaserDot( CBaseEntity *pLaserDot, bool bEnable )
{
	CLaserDot *pDot = assert_cast< CLaserDot* >(pLaserDot );
	if ( bEnable )
	{
		pDot->TurnOn();
	}
	else
	{
		pDot->TurnOff();
	}
}

CLaserDot::CLaserDot( void )
{
	m_hTargetEnt = NULL;
	m_bIsOn = true;

#ifndef CLIENT_DLL
	g_LaserDotList.Insert( this );
#endif
}

CLaserDot::~CLaserDot( void )
{
#ifndef CLIENT_DLL
	g_LaserDotList.Remove( this );
#endif
}

#ifndef CLIENT_DLL
	//-----------------------------------------------------------------------------
	// Purpose: 
	// Input  : &origin - 
	// Output : CLaserDot
	//-----------------------------------------------------------------------------
	CLaserDot *CLaserDot::Create( const Vector &origin, CBaseEntity *pOwner, bool bVisibleDot )
	{
		//CLaserDot *pLaserDot = (CLaserDot *)CBaseEntity::Create( "env_laserdot", origin, QAngle(0,0,0) );
		CLaserDot *pLaserDot = CREATE_ENTITY(CLaserDot, "env_laserdot");

		if ( pLaserDot == NULL )
			return NULL;

		// set it up
		pLaserDot->SetLocalOrigin(origin);
		pLaserDot->SetLocalAngles(QAngle(0, 0, 0));
		pLaserDot->SetOwnerEntity(pOwner);

		pLaserDot->m_bVisibleLaserDot = bVisibleDot;
		pLaserDot->SetMoveType( MOVETYPE_NONE );
		pLaserDot->AddSolidFlags( FSOLID_NOT_SOLID );
		pLaserDot->AddEffects( EF_NOSHADOW );

		UTIL_SetSize( pLaserDot, vec3_origin, vec3_origin );

		//Create the graphic
		pLaserDot->SpriteInit( "sprites/redglow1.vmt", origin );

		pLaserDot->SetName( AllocPooledString("TEST") );
		
		pLaserDot->SetTransparency( kRenderGlow, 255, 255, 255, 255, kRenderFxNoDissipation );
		pLaserDot->SetScale( 0.25f );

		pLaserDot->SetContextThink( &CLaserDot::LaserThink, gpGlobals->curtime + 0.1f, g_pLaserDotThink );
		pLaserDot->SetSimulatedEveryTick( true );

		if ( !bVisibleDot )
		{
			pLaserDot->MakeInvisible();
		}

		return pLaserDot;
	}
#endif

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CLaserDot::LaserThink( void )
{
	SetNextThink( gpGlobals->curtime + 0.05f, g_pLaserDotThink );

	if ( GetOwnerEntity() == NULL )
		return;

	Vector	viewDir = GetAbsOrigin() - GetOwnerEntity()->GetAbsOrigin();
	float	dist = VectorNormalize( viewDir );

	float	scale = RemapVal( dist, 32, 1024, 0.005f, 0.25f );
	float	scaleOffs = random->RandomFloat( -scale * 0.25f, scale * 0.25f );

	scale = clamp( scale + scaleOffs, 0.05f, 16.0f );

	SetScale( scale );
}

void CLaserDot::SetLaserPosition( const Vector &origin, const Vector &normal )
{
	SetAbsOrigin( origin );
	m_vecSurfaceNormal = normal;
}

Vector CLaserDot::GetChasePosition()
{
	return GetAbsOrigin() - m_vecSurfaceNormal * 10;
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CLaserDot::TurnOn( void )
{
	m_bIsOn = true;
	if ( m_bVisibleLaserDot )
	{
		BaseClass::TurnOn();
	}
}


//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CLaserDot::TurnOff( void )
{
	m_bIsOn = false;
	if ( m_bVisibleLaserDot )
	{
		BaseClass::TurnOff();
	}
}


//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CLaserDot::MakeInvisible( void )
{
	BaseClass::TurnOff();
}

#ifdef CLIENT_DLL
	void CLaserDot::ClientThink(void)
	{
		Vector vecMuzzlePos, vecEndPos, vecForward, vecLaserPos;
		CSDKPlayer *pPlayer = NULL;

		// make sure everything is the same as the server
		SetTransparency(kRenderGlow, 255, 255, 255, 255, kRenderFxNoDissipation);
		SetScale(0.25f);

		// pull the player
		pPlayer = dynamic_cast<CSDKPlayer *>(GetOwnerEntity());

		// make sure we have a player and that it is the local one
		// if it is we need to update the position on the client so that our laser
		// isn't floppy.  i'm not sure if there is a better way to do this
		// at any rate, if the owner isn't the local player we don't care if
		// the laser is a bit behind
		if(!pPlayer || pPlayer != CSDKPlayer::GetLocalSDKPlayer())
			return;

		// get the current direction of the weapon
		vecMuzzlePos = pPlayer->Weapon_ShootPosition();

		// move down the eye vector to the end of the trace
		pPlayer->EyeVectors(&vecForward);
		vecEndPos = vecMuzzlePos + (vecForward * MAX_TRACE_LENGTH);
		
		// trace out for the endpoint
		trace_t	tr;
		UTIL_TraceLine(vecMuzzlePos, vecEndPos, (MASK_SHOT & ~CONTENTS_WINDOW), this, COLLISION_GROUP_NONE, &tr);

		// move us to the correct spot
		vecLaserPos = tr.endpos;
		SetLaserPosition(vecLaserPos, tr.plane.normal);
	}
#endif
